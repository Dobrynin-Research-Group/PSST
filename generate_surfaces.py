import collections
import numpy as np
import pandas as pd
from scipy import interpolate
import json
from generate_data import generate_grid

Bin = collections.namedtuple('Bin', ['min', 'max', 'num_bins'])

def generate_surface_bins():
    """
    Read json file "surface_bins.json" to output bins to create (nw, phi, eta_sp) space
    
        Arguments:
            None

        Returns:
            Parameters: (dict) Dictionary of tuples. Number of bins [0], minimum bin [1] and maximum bin [2] for each coordinate of Nw, phi, and eta_sp
    """

    with open('surface_bins.json') as f:
        bin_data = json.load(f)

    bins = {}
    bins['Nw'] = Bin(bin_data['Nw_min_bin'], bin_data['Nw_max_bin'], bin_data['Nw_num_bins'])
    bins['phi'] = Bin(bin_data['phi_min_bin'], bin_data['phi_max_bin'], bin_data['phi_num_bins'])
    bins['eta_sp'] = Bin(bin_data['eta_sp_min_bin'], bin_data['eta_sp_max_bin'], bin_data['eta_sp_num_bins'])

    return bins

def bin_data(df, bins, Bg, Bth):
    """
    Create a grid of specific viscosity vs (Nw, phi) for each value of Bg, Bth, and Pe
    
        Arguments:
            df: (DataFrame) DataFrame generated by generate_data.py
            bins: (Dictionary) Input parameters that determine bounds of (Nw, phi, eta_sp) space and number of bins in each dimension
            Bg: (float) B-parameter in good regime
            Bth: (float) B-parameter in theta regime
        Returns:
            None
    """
    df2 = df.copy()
    # define features
    features = ['Nw', 'phi', 'eta_sp']
    # log before normalizing (nw, phi, eta_sp) space
    df2[features] = np.log10(df2[features])

    # normalize (nw, phi, eta_sp) space to (0, 1)
    df2['Nw'] = (df2['Nw']-np.log10(bins['Nw'].min))/(np.log10(bins['Nw'].max)-np.log10(bins['Nw'].min))
    df2['phi'] = (df2['phi']-np.log10(bins['phi'].min))/(np.log10(bins['phi'].max)-np.log10(bins['phi'].min))
    df2['eta_sp'] = (df2['eta_sp']-np.log10(bins['eta_sp'].min))/(np.log10(bins['eta_sp'].max)-np.log10(bins['eta_sp'].min))

    # set path of save folder
    path1 = 'grid_data\\'
    for k in np.unique(df2['Pe']):
        # take data for each Pe
        data = df2[df2['Pe']==k]
        x = data['Nw']
        y = data['phi']
        z = data['eta_sp']
        # set up (0,1) mesh grid space, each bin represents a location of (nw, phi)
        xplotv = np.linspace(0,1,bins['Nw'].num_bins)
        yplotv = np.linspace(0,1,bins['phi'].num_bins)
        xplot, yplot = np.meshgrid(xplotv, yplotv)
        # play with different methods (linear vs cubic)
         
         # Maybe deal with edges or zero values with nearest method?
        #zgriddata_nn = interpolate.griddata(
        #    np.array([x.ravel(),y.ravel()]).T,
        #    z.ravel(),
        #    np.array([xplot.ravel(),yplot.ravel()]).T,
        #    method='nearest')

        zgriddata = interpolate.griddata(
            np.array([x.ravel(),y.ravel()]).T,
            z.ravel(),
            np.array([xplot.ravel(),yplot.ravel()]).T,
            method='cubic',
            fill_value=0)
        # for areas where fill_value = 0 (mostly edges), return value of data point closest to the point of interpolation
        #zgriddata[np.where(zgriddata==0)] = zgriddata_nn[np.where(zgriddata==0)]
        #zgriddata[np.where(zgriddata<0)] = 0
        # each bin of data_save represents a value of normalized eta_sp given data of normalized (nw, phi)
        data_save = zgriddata.reshape(bins['phi'].num_bins,bins['Nw'].num_bins)
        np.savetxt(f'{path1}Bg_{Bg:.2f}_Bth_{Bth:.2f}_Pe_{k:.1f}.txt', data_save)

# Main
def main():
    path_read = 'generated_data\\'
    grid = generate_grid()
    bins = generate_surface_bins()
    for a in grid['Bg']:
        for b in grid['Bth']:
            df = pd.read_csv(f"{path_read}dataset_{a:.2f}_{b:.2f}.csv")
            bin_data(df, bins, a, b)

if __name__ == '__main__':
    main()